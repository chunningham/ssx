---
description: SSX Configuration Guide
---

# ðŸ›  Configuring SSX

## Overview

SSX works on both server and client _without_ configuration. However, you can access a robust feature set by enabling and configuring some available options.

Below are a few examples and explanations of the configuration options:

### **Enabling DAO Login**

SSX enables an easy way for users to sign in on behalf of a Gnosis Safe multisig on your platform that they have been delegated access to. It [provides an easy flow](../appendix/dao-login-workflow.md) that users can take to either log in as themselves or on behalf of the multisig. Here is an example of how you enable that field:

<pre class="language-javascript"><code class="lang-javascript"><strong>const buttonHandlerWeb3ModalGnosis = async () => {
</strong>    const ssx = new SSX({
      enableDaoLogin: true,
    });
    await ssx.signIn();
};</code></pre>

### Customizing Fields in the SIWE Message

SSX enables developers an easy way to configure the fields of their Sign-in with Ethereum (SIWE) message using the [`siweConfig`](./#session-config) option. This option allows you to overwrite the fields found in the SIWE message. This option can allow you to create SIWE messages that may not be valid in specific environments, so use this option with care.

```javascript
const buttonHandlerWeb3ModalGnosis = async () => {
    const ssx = new SSX({
      siweConfig: {
        statement: "Sign in to use our service today!"
        requestId: "unique-id-for-specific-purpose",
      },
    });
    await ssx.signIn();
};
```

## Config Options

### SSX-Client Configuration Options

The configuration options for SSX are defined [here](../reference/ssx/ssx.ssxconfig/) and include: `enableDaoLogin`, `providers`, and `siweConfig`.

#### [enableDaoLogin](../appendix/dao-login-workflow.md)

SSX has support for lookup on the [DelegationRegistry](https://etherscan.io/address/0x469788fE6E9E9681C6ebF3bF78e7Fd26Fc015446) Smart Contract, used by Gnosis Safe, built in. This enables a user to sign in on behalf of a Gnosis Safe, or any other address that has delegated access to that user. Enabling `enableDaoLogin` prompts the user to select if they want to sign in with their Externally Owned Account (their wallet) or on behalf of an address they are a delegee of. A detailed explanation of the DAO Login Workflow is available [here](../appendix/dao-login-workflow.md).

```javascript
const ssx = new SSX({
    enableDaoLogin: true,
});
```

#### [siweConfig](broken-reference)

`siweConfig` is a field that lets you set default values for SIWE messages. These values will overwrite fields that are automatically generated by SSX and could lead to invalid messages if misconfigured. Valid options can be found [here](https://github.com/spruceid/ssx-rs/blob/main/client/src/session/types.rs#L22).

```javascript
const ssx = new SSX({
    siweConfig: { requestId: "some_id" },
});
```

#### [providers](broken-reference)

SSX acts as a super-provider for your dapp to make multiple resources available to your dapp with minimal configuration: [a web3 provider ](./#providers.web3)(to connect to your wallet), [an RPC provider](./#providers.rpc) (to connect to blockchains) and [a server provider](./#providers.server) (to connect to a server using ssx).

#### [providers.web3](../reference/ssx/ssx.ssxproviderweb3/)

Dapps interact with the Ethereum network by accessing the [Ethereum JavaScript provider API](https://eips.ethereum.org/EIPS/eip-1193), which is usually injected into the browser by an Ethereum wallet. SSX works with any wallet by connecting to the wallet's implementation of [Web3Provider](https://docs.ethers.io/v5/api/providers/other/#Web3Provider), which is passed to the config as seen below.

SSX then manages this wallet connection, creates and displays the Sign-in with Ethereum message, and handles signed messages.

```javascript
const ssx = new SSX({
    providers: { web3: { driver: await web3modal.connect() } },
});
```

#### [providers.server](broken-reference)

The server field is an optional reference to a corresponding server running `ssx-server`. Providing these fields enables automatic communication with the server to establish sessions upon successful SIWE signing. For more information on configuring `ssx-server`, check out the [readme-1.md](../readme-1.md "mention"):

```javascript
const ssx = new SSX({
    providers: { server: { host: "http://localhost:3001" } }
});
```

#### [providers.rpc](../reference/ssx/ssx.ssxrpcprovider.md)

SSX Server supports all JSON RPC providers that are currently supported by [`ethers`](https://docs.ethers.io/v5/api/providers/api-providers/#api-providers), requiring only the credentials from the desired provider to instantiate it. The SSX library provides valid enumerated options for various RPC providers, but developers can also just use the valid strings, as seen below. A list of supported RPC providers can be found [here](../reference/ssx/ssx.ssxrpcproviders.md).

```javascript
import { SSX, SSXRPCProviders, SSXInfuraProviderNetworks } from '@spruceid/ssx-server';

const ssx = new SSX({
    providers: {
      rpc: {
        service: SSXRPCProviders.SSXInfuraProvider,
        network: SSXInfuraProviderNetworks.MAINNET,
        apiKey: process.env.INFURA_API_KEY ?? "",
      },
    },
});

// OR 

const ssx = new SSX({
    providers: {
      rpc: {
        service: "infura",
        network: "homestead",
        apiKey: process.env.INFURA_API_KEY ?? "",
      },
    },
});

// RPC usage example
const rpcExample = async () => {
  await ssx.signIn();
  const address = ssx.address()
  const userbalance = await ssx.provider.getBalance(address);
  const currentBlock = await ssx.provider.getBlockNumber();
}
```

### SSX-Server Configuration Options

The configuration options for `ssx-server` are defined [here](../reference/ssx-server/ssx-server.ssxserverconfig/) and include: `signingKey`, `useSecureCookies`, and `providers`.&#x20;

{% hint style="info" %}
SSX Server supports multiple server configurations. To explore setting a specific server environment with SSX, check out [configuring-ssx-server.md](configuring-ssx-server.md "mention")
{% endhint %}

#### [signingKey](../reference/ssx-server/ssx-server.ssxserverconfig/ssx-server.ssxserverconfig.signingkey.md)

This is an optional, string field. It is the key that is used to sign cookies to prevent cookie tampering on the client. The server will issue unsigned cookies if this field is not provided. It is recommended for production environments.

```javascript
const ssx = new SSXServer({
  signingKey: process.env.SSX_SIGNING_KEY,
});
```

#### [useSecureCookies](../reference/ssx-server/ssx-server.ssxserverconfig/ssx-server.ssxserverconfig.usesecurecookies.md)

This is an optional, boolean field. It adds extra protection to your cookies by changing their attributes to be more secure. This defaults to `true` in production environments.&#x20;

{% hint style="danger" %}
Setting this to`false` is insecure and not recommended for production environments!
{% endhint %}

```javascript
const ssx = new SSXServer({
  useSecureCookies: true,
});
```

#### [providers](broken-reference)

If you are using `enableDaoLogin` at your front-end application you will need to also setup a provider for the `SSXServer`. By doing so you will also have access to that provider in any of your routes by getting `req.ssx.provider`, which will also make it easier if you have to make any RPC calls to a node.

#### [providers.metrics](../reference/ssx-server/ssx-server.ssxmetricsprovider.md)

Metrics is an optional, object field. It contains the service, `ssx,` and the apiKey that is used when sending metrics to the [SSX Dashboard](../accessing-the-ssx-dashboard.md). This ties your server instance and its metrics and logs to your platform account.

```javascript
import { SSXServer } from "@spruceid/ssx-server";

const ssx = new SSXServer({
  providers: {
    metrics: { service: "ssx", apiKey: process.env.SSX_API_KEY },
  },
});
```

#### [providers.rpc](../reference/ssx-server/ssx-server.ssxrpcprovider.md)

SSX Server supports all JSON RPC providers that are currently supported by [`ethers`](https://docs.ethers.io/v5/api/providers/api-providers/#api-providers), requiring only the credentials from the desired provider to instantiate it.

```javascript
import { SSXServer } from "@spruceid/ssx-server";

const ssx = new SSXServer({
  providers: {
    rpc: { service: "infura", apiKey: process.env.INFURA_API_KEY },
  },
});

// later...
const currentBlock = await ssx.provider.getBlockNumber();
```

#### [providers.sessionConfig](../reference/ssx-server/ssx-server.ssxsessionstoreconfig/)

This optional field is for managing the session store. It includes a [`sessionOptions`](https://github.com/DefinitelyTyped/DefinitelyTyped/blob/a24d35afe48f7fb702e7617b983ddca1904ba36b/types/express-session/index.d.ts#L52) field and a `store` connector function. Under the hood, SSX connects to session stores that implement [express-session's EventEmitter API](https://github.com/expressjs/session#compatible-session-stores) and uses the same configuration options to do so. These fields are automatically set by your SSX configuration

The `store` connector is a function that is run on initialization that initializes and connects to the session store being used. It should return a configured instance of a store. An example implementation using [SSX and Redis of this is available here](../scaling-ssx-server.md#configuration-in-express-server).

{% hint style="warning" %}
If `providers.sessionConfig` is not provided, SSX Server defaults to using an in-memory store that resets with the server. It is recommended to use a [compatible persistent store](https://github.com/expressjs/session#compatible-session-stores). Check out [Scaling SSX Server](../scaling-ssx-server.md#handle-sessions-at-scale) to learn more.
{% endhint %}

```javascript
import { SSXServer } from "@spruceid/ssx-server";

const ssx = new SSXServer({
  providers: {
    sessionConfig: {
      sessionOptions: {
        // ex: Recognize cookies signed by other keys
        secret: [process.env.SSX_SIGNING_KEY, process.env.OTHER_COOKIE_KEY]
      },
      store: (session) => {
        // ex: dynamodb for session store [connect-dynamodb](https://www.npmjs.com/package/connect-dynamodb)
        const DynamoDBStore = require('connect-dynamodb')(session);
        const dynamoDBoptions = {}; // configure to connect
        return new DynamoDBStore(dynamoDBoptions)
      },
    },
  },
});
```

